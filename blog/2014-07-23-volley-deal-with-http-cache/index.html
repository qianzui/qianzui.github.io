<!DOCTYPE html><html><head><meta name="google-site-verification" content="l5IS67XsnEoE1xwi9zQCgXv7Axe5Uds5_IOXOmlZt6U"><meta name="baidu-site-verification" content="6Z8140QnmW"><meta charset="utf-8"><title>Volley对HTTP缓存的处理 | qianzui&#39;s blog</title><meta name="keywords" content="Volley,cache,http,Android"><meta http-equiv="content-language" content="zh-CN"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content="Volley对HTTP缓存的处理"><meta property="og:type" content="article"><meta property="og:title" content="Volley对HTTP缓存的处理"><meta property="og:url" content="http://qianzui.github.io/blog/2014-07-23-volley-deal-with-http-cache/index.html"><meta property="og:site_name" content="qianzui's blog"><meta property="og:description" content="Volley对HTTP缓存的处理"><meta property="og:updated_time" content="2016-05-24T12:10:22.650Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Volley对HTTP缓存的处理"><meta name="twitter:description" content="Volley对HTTP缓存的处理"><link rel="alternative" href="/atom.xml" title="qianzui&#39;s blog" type="application/atom+xml"><link rel="icon" href="/css/images/favicon.png"><link href="//fonts.useso.com/css?family=Open+Sans:400italic,400,600" rel="stylesheet" type="text/css"><link href="//fonts.useso.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css"><link rel="stylesheet" href="/css/style.css"><link href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"></head><body><div id="container"><header id="header"><div id="header-main" class="header-inner"><div class="outer"><a href="/" id="logo"><i class="logo"></i><span class="site-title">qianzui&#39;s blog</span></a><nav id="main-nav"><a class="main-nav-link" href="/">主页</a> <a class="main-nav-link" href="/archives">归档</a> <a class="main-nav-link" href="/about">关于</a></nav><nav id="sub-nav"><div class="profile" id="profile-nav"><a id="profile-anchor" href="javascript:;"><img class="avatar" src="http://cdn.fds.api.xiaomi.com/b2c-bbs/yoJtzqV9IWFb.png"><i class="fa fa-caret-down"></i></a></div></nav><div id="search-form-wrap"><form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"></button><input type="hidden" name="sitesearch" value="http://qianzui.github.io"></form></div></div></div><div id="main-nav-mobile" class="header-sub header-inner"><table class="menu outer"><tr><td><a class="main-nav-link" href="/">主页</a></td><td><a class="main-nav-link" href="/archives">归档</a></td><td><a class="main-nav-link" href="/about">关于</a></td><td><form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><input type="hidden" name="sitesearch" value="http://qianzui.github.io"></form></td></tr></table></div></header><div class="outer"><aside id="profile"><div class="inner profile-inner"><div class="base-info profile-block"><img id="avatar" src="http://cdn.fds.api.xiaomi.com/b2c-bbs/yoJtzqV9IWFb.png"><h2 id="name">千醉</h2><h3 id="title">Android Developer</h3><span id="location"><i class="fa fa-map-marker"></i>Beijing, China</span> <a id="follow" href="https://github.com/qianzui">关注我</a></div><div class="article-info profile-block"><div class="article-info-block">14 <span>文章</span></div><div class="article-info-block">17 <span>标签</span></div></div><div class="contact-info profile-block"><table class="contact-list"><tr><td><a href="http://github.com/qianzui" target="_blank" title="github"><div style="font-size: 26px"><i class="fa fa-github"></i></div></a></td><td><a href="http://weibo.com/qianzuiz" target="_blank" title="weibo"><div style="font-size: 26px"><i class="fa fa-weibo"></i></div></a></td><td><a href="https://plus.google.com/u/0/101333418418093394556/posts" target="_blank" title="google-plus"><div style="font-size: 26px"><i class="fa fa-google-plus"></i></div></a></td><td><a href="https://twitter.com/cuanzui" target="_blank" title="twitter"><div style="font-size: 26px"><i class="fa fa-twitter"></i></div></a></td></tr></table></div></div></aside><section id="main"><article id="post-volley-deal-with-http-cache" class="article article-type-post" itemscope itemprop="blogPost"><div class="article-inner"><header class="article-header"><h1 class="article-title" itemprop="name">Volley对HTTP缓存的处理</h1><div class="article-meta"><div class="article-date"><i class="fa fa-calendar"></i> <a href="/blog/2014-07-23-volley-deal-with-http-cache/"><time datetime="2014-07-23T11:11:31.000Z" itemprop="datePublished">2014-07-23</time></a></div><div class="article-category"><i class="fa fa-folder"></i> <a class="article-category-link" href="/categories/Http/">Http</a></div></div></header><div class="article-entry" itemprop="articleBody"><p>客户端开发中，调用远程服务接口获取数据更新UI是最常见不过的了。有些纯展示的页面服务端数据的更新其实没那么快，如果每次打开这种页面都要向服务器请求数据，而服务端数据可能在你上次请求之后并没有更新数据，这样就造成了流量的浪费，更重要的，每次和服务器交互都是耗时的，获取数据间隙严重影响用户体验，而这一切本是可以避免的（数据明明没有任何更新，为什么还要再次发送请求呢？同样的数据上次已经获取过了啊）。</p><p>其实最好的请求是不必与服务器进行通信的请求：通过响应本地的副本，避免所有的网络延迟以及数据传输的成本。HTTP1.1 规范定义了一系列服务器返回的不同的 Cache-Control 指令，控制客户端如何缓存某个响应以及缓存多长时间。Volley按照HTTP规范的定义，实现了请求缓存的功能。</p><p>##网络缓存的处理<br>Volley在初始化的时候默认会启动5个线程，4个network线程和1个cache线程（其实这里可以优化一下，像Picasso那样根据用户网络类型的不同（wifi、4G、3G、2G等），动态设置network线程的数量）。如果一个新的Request添加到RequestQueue之后，请求如果没有设置禁用缓存的话（默认是开启的，mShouldCache = true）会把这次请求添加到cache线程所维护的队列中，看一下CacheDispatcher的run方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) VolleyLog.v(<span class="string">"start new dispatcher"</span>);</span><br><span class="line">    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make a blocking call to initialize the cache.</span></span><br><span class="line">    mCache.initialize();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Get a request from the cache triage queue, blocking until</span></span><br><span class="line">            <span class="comment">// at least one is available.</span></span><br><span class="line">            <span class="keyword">final</span> Request&lt;?&gt; request = mCacheQueue.take();</span><br><span class="line">            request.addMarker(<span class="string">"cache-queue-take"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If the request has been canceled, don't bother dispatching it.</span></span><br><span class="line">            <span class="keyword">if</span> (request.isCanceled()) &#123;</span><br><span class="line">                request.finish(<span class="string">"cache-discard-canceled"</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Attempt to retrieve this item from cache.</span></span><br><span class="line">            Cache.Entry entry = mCache.get(request.getCacheKey());</span><br><span class="line">            <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">                request.addMarker(<span class="string">"cache-miss"</span>);</span><br><span class="line">                <span class="comment">// Cache miss; send off to the network dispatcher.</span></span><br><span class="line">                mNetworkQueue.put(request);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 下面的代码省略，后面再分析</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// We may have been interrupted because it was time to quit.</span></span><br><span class="line">            <span class="keyword">if</span> (mQuit) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第7行进入死循环之前先初始化DiskBaseCache。<br>13行BlockingQueue的take()方法会阻塞，直到队列中有元素的时候才会往下继续执行。<br>23行先尝试从本地的文件缓存中去取，如果取不到数据则把该次请求交给network线程处理。看下NetworkDispatcher的run()方法。<br><a id="more"></a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">// Perform the network request.</span></span><br><span class="line">NetworkResponse networkResponse = mNetwork.performRequest(request);</span><br><span class="line">request.addMarker(<span class="string">"network-http-complete"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// If the server returned 304 AND we delivered a response already,</span></span><br><span class="line"><span class="comment">// we're done -- don't deliver a second identical response.</span></span><br><span class="line"><span class="keyword">if</span> (networkResponse.notModified &amp;&amp; request.hasHadResponseDelivered()) &#123;</span><br><span class="line">    request.finish(<span class="string">"not-modified"</span>);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Parse the response here on the worker thread.</span></span><br><span class="line">Response&lt;?&gt; response = request.parseNetworkResponse(networkResponse);</span><br><span class="line">request.addMarker(<span class="string">"network-parse-complete"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Write to cache if applicable.</span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> Only update cache metadata instead of entire record for 304s.</span></span><br><span class="line"><span class="keyword">if</span> (request.shouldCache() &amp;&amp; response.cacheEntry != <span class="keyword">null</span>) &#123;</span><br><span class="line">    mCache.put(request.getCacheKey(), response.cacheEntry);</span><br><span class="line">    request.addMarker(<span class="string">"network-cache-written"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Post the response back.</span></span><br><span class="line">request.markDelivered();</span><br><span class="line">mDelivery.postResponse(request, response);</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>第3行调用BasicNetwork的performRequest方法发送请求，并把响应的code、header、content等信息封装成NetworkResponse返回。<br>第8行如果返回是responseCode是304并且这次请求已经把结果向上回调的话，不再继续向下执行。<br>14行调用请求的parseNetworkResponse()方法，该方法是abstract的，继承Request的请求要实现该方法的逻辑，完成对HttpResponse的处理，根据自己项目的需要，通用的做法是把请求的响应数据转化为我们需要的bean，处理完成后，生成parseNetworkResponse()返回的Response会调用HttpHeaderParser.parseCacheHeaders()先生成Cache.Entry。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Cache.<span class="function">Entry <span class="title">parseCacheHeaders</span><span class="params">(NetworkResponse response)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    Map&lt;String, String&gt; headers = response.headers;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> serverDate = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> lastModified = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> serverExpires = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> softExpire = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> finalExpire = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> maxAge = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> staleWhileRevalidate = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> hasCacheControl = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> mustRevalidate = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    String serverEtag = <span class="keyword">null</span>;</span><br><span class="line">    String headerValue;</span><br><span class="line"></span><br><span class="line">    headerValue = headers.get(<span class="string">"Date"</span>);</span><br><span class="line">    <span class="keyword">if</span> (headerValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">        serverDate = parseDateAsEpoch(headerValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    headerValue = headers.get(<span class="string">"Cache-Control"</span>);</span><br><span class="line">    <span class="keyword">if</span> (headerValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">        hasCacheControl = <span class="keyword">true</span>;</span><br><span class="line">        String[] tokens = headerValue.split(<span class="string">","</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tokens.length; i++) &#123;</span><br><span class="line">            String token = tokens[i].trim();</span><br><span class="line">            <span class="keyword">if</span> (token.equals(<span class="string">"no-cache"</span>) || token.equals(<span class="string">"no-store"</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (token.startsWith(<span class="string">"max-age="</span>)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    maxAge = Long.parseLong(token.substring(<span class="number">8</span>));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (token.startsWith(<span class="string">"stale-while-revalidate="</span>)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    staleWhileRevalidate = Long.parseLong(token.substring(<span class="number">23</span>));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (token.equals(<span class="string">"must-revalidate"</span>) || token.equals(<span class="string">"proxy-revalidate"</span>)) &#123;</span><br><span class="line">                mustRevalidate = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    headerValue = headers.get(<span class="string">"Expires"</span>);</span><br><span class="line">    <span class="keyword">if</span> (headerValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">        serverExpires = parseDateAsEpoch(headerValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    headerValue = headers.get(<span class="string">"Last-Modified"</span>);</span><br><span class="line">    <span class="keyword">if</span> (headerValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">        lastModified = parseDateAsEpoch(headerValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    serverEtag = headers.get(<span class="string">"ETag"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cache-Control takes precedence over an Expires header, even if both exist and Expires</span></span><br><span class="line">    <span class="comment">// is more restrictive.</span></span><br><span class="line">    <span class="keyword">if</span> (hasCacheControl) &#123;</span><br><span class="line">        softExpire = now + maxAge * <span class="number">1000</span>;</span><br><span class="line">        finalExpire = mustRevalidate</span><br><span class="line">                ? softExpire</span><br><span class="line">                : softExpire + staleWhileRevalidate * <span class="number">1000</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (serverDate &gt; <span class="number">0</span> &amp;&amp; serverExpires &gt;= serverDate) &#123;</span><br><span class="line">        <span class="comment">// Default semantic for Expire header in HTTP specification is softExpire.</span></span><br><span class="line">        softExpire = now + (serverExpires - serverDate);</span><br><span class="line">        finalExpire = softExpire;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Cache.Entry entry = <span class="keyword">new</span> Cache.Entry();</span><br><span class="line">    entry.data = response.data;</span><br><span class="line">    entry.etag = serverEtag;</span><br><span class="line">    entry.softTtl = softExpire;</span><br><span class="line">    entry.ttl = finalExpire;</span><br><span class="line">    entry.serverDate = serverDate;</span><br><span class="line">    entry.lastModified = lastModified;</span><br><span class="line">    entry.responseHeaders = headers;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> entry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>所有对HTTP缓存的处理逻辑都在这个方法里了。按照http协议的格式，通过对响应header的解析，构造Cache.Entry的各个参数。<br>24~46行解析”Cache-Control”头部，<br>“no-cache”：表示客户端必须先与服务器确认返回的响应是否被更改，然后才能使用该响应来满足后续对同一个url的请求。也就是说服务器这次给你返回了”Cache-Control:no-cache”，本次响应你可以无视，因为无论你保存不保存，如果下次再请求该url的时候，你还是没办法直接使用本地的缓存（即使你保存了），因为按照协议规定你必须再次请求服务器获取最新数据，也就是说每次请求都必须向服务器发送。Volley在这里直接忽略了响应信息，而FireFox浏览器则会缓存响应。</p><p>“no-store”：比较严格，标示服务器禁止客户端保存这次请求的响应。<br>这两种情况下不保存响应信息，直接返回null。</p><p>“max-age”：单位是秒，表示从此刻起，多少秒之内再次访问该url时可以不必向服务发送请求，直接使用本地缓存即可。</p><p>“stale-while-revalidate”：用的较少，查阅《http协议详解》，该字段表示缓存过期后还可以继续使用多久，单位是秒。RFC5861也有<a href="https://tools.ietf.org/html/rfc5861" target="_blank" rel="external">相关说明和例子</a></p><p>“must-revalidate”、”proxy-revalidate”：强制要求缓存过期后必须请求服务器，防止某些情况下客户端会忽略服务器设置的缓存过期时间。</p><p>根据上面的各个字段，控制客户端如何缓存响应以及缓存多长时间，计算该次请求缓存的过期和刷新时间等。</p><p>48行是解析”Expires”头部，这是HTTP1.0规范设置缓存过期时间，在HTTP1.1中已经被”Cache-Control”取代，62~71行可以看到会有限使用”Cache-Control”计算缓存过期时间，在没有”Cache-Control”头部的时候才会使用”Expires”。</p><p>53行解析”Last-Modified”，记录服务器最后一次修改时间。<br>58行解析”ETag”，ETag信息是服务器生成的一个随机令牌，通常是文件内容的哈希值或者某个其他指纹码，便于服务器验证资源是否有修改。</p><p>再次回到NetworkDispatcher的run()方法中，response获取之后，会把本次请求的Cache.Entry信息保存到文件缓存中。然后把结果向上回调，同时把该次请求标识为已发送回调。</p><p>至此，一次全新的请求就执行完了，可以看到响应信息会通过按照HTTP协议的格式解析然后保持到本地文件中去。</p><p>回过头来再来看CacheDispatcher的run()方法后面的代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If it is completely expired, just send it to the network.</span></span><br><span class="line"><span class="keyword">if</span> (entry.isExpired()) &#123;</span><br><span class="line">    request.addMarker(<span class="string">"cache-hit-expired"</span>);</span><br><span class="line">    request.setCacheEntry(entry);</span><br><span class="line">    mNetworkQueue.put(request);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// We have a cache hit; parse its data for delivery back to the request.</span></span><br><span class="line">request.addMarker(<span class="string">"cache-hit"</span>);</span><br><span class="line">Response&lt;?&gt; response = request.parseNetworkResponse(</span><br><span class="line">        <span class="keyword">new</span> NetworkResponse(entry.data, entry.responseHeaders));</span><br><span class="line">request.addMarker(<span class="string">"cache-hit-parsed"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!entry.refreshNeeded()) &#123;</span><br><span class="line">    <span class="comment">// Completely unexpired cache hit. Just deliver the response.</span></span><br><span class="line">    mDelivery.postResponse(request, response);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Soft-expired cache hit. We can deliver the cached response,</span></span><br><span class="line">    <span class="comment">// but we need to also send the request to the network for</span></span><br><span class="line">    <span class="comment">// refreshing.</span></span><br><span class="line">    request.addMarker(<span class="string">"cache-hit-refresh-needed"</span>);</span><br><span class="line">    request.setCacheEntry(entry);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Mark the response as intermediate.</span></span><br><span class="line">    response.intermediate = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Post the intermediate response back to the user and have</span></span><br><span class="line">    <span class="comment">// the delivery then forward the request along to the network.</span></span><br><span class="line">    mDelivery.postResponse(request, response, <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                mNetworkQueue.put(request);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// Not much we can do about this.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果一个请求已经缓存到本地了，再次请求的话尝试先从本地缓存文件中取，假设缓存没有被清理，这时候是可以取到数据的。拿到Cache.Entry信息后，判断缓存是否过期，如果没有过期，则判断是否需要刷新，如果不需要刷新，直接把缓存数据返回，不再往下执行。如果需要刷新的话，则先把缓存数据向上回调，并把该次请求标识为已发送过回调(request.markDelivered())，防止服务端返回304时再次向上回调，同时再发起一个网络请求。在发送请求时会添加上cache相关的header信息。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addCacheHeaders</span><span class="params">(Map&lt;String, String&gt; headers, Cache.Entry entry)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// If there's no cache entry, we're done.</span></span><br><span class="line">    <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (entry.etag != <span class="keyword">null</span>) &#123;</span><br><span class="line">        headers.put(<span class="string">"If-None-Match"</span>, entry.etag);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (entry.lastModified &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        Date refTime = <span class="keyword">new</span> Date(entry.lastModified);</span><br><span class="line">        headers.put(<span class="string">"If-Modified-Since"</span>, DateUtils.formatDate(refTime));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>If-None-Match:带上上次服务器下发的验证令牌，服务器会针对当前最新的资源检查令牌，如果未被修改过，则返回304 Not Modified响应。</p><p>If-Modified-Since：带上上次服务器返回的资源修改时间，服务器会会针对当前最新资源的更新时间进行判断，如果此后没更新，则返回304 Not Modified响应。</p><p>服务器端根据header里的参数进行逻辑判断，返回200或304，如果是304，客户端直接使用本地缓存数据向上回调，如果返回200，则用返回的数据向上回调，同时更新缓存信息。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">HttpResponse httpResponse = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">byte</span>[] responseContents = <span class="keyword">null</span>;</span><br><span class="line">Map&lt;String, String&gt; responseHeaders = Collections.emptyMap();</span><br><span class="line"><span class="keyword">try</span> &#123;   </span><br><span class="line">    <span class="comment">// Gather headers.</span></span><br><span class="line">    Map&lt;String, String&gt; headers = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">    addCacheHeaders(headers, request.getCacheEntry());</span><br><span class="line">    httpResponse = mHttpStack.performRequest(request, headers);</span><br><span class="line">    StatusLine statusLine = httpResponse.getStatusLine();</span><br><span class="line">    <span class="keyword">int</span> statusCode = statusLine.getStatusCode();</span><br><span class="line">    responseHeaders = convertHeaders(httpResponse.getAllHeaders());</span><br><span class="line">    <span class="comment">// Handle cache validation.</span></span><br><span class="line">    <span class="keyword">if</span> (statusCode == HttpStatus.SC_NOT_MODIFIED) &#123;</span><br><span class="line">        Entry entry = request.getCacheEntry();</span><br><span class="line">        <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> NetworkResponse(HttpStatus.SC_NOT_MODIFIED, <span class="keyword">null</span>,</span><br><span class="line">                    responseHeaders, <span class="keyword">true</span>,</span><br><span class="line">                    SystemClock.elapsedRealtime() - requestStart);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// A HTTP 304 response does not have all header fields. We</span></span><br><span class="line">        <span class="comment">// have to use the header fields from the cache entry plus</span></span><br><span class="line">        <span class="comment">// the new ones from the response.</span></span><br><span class="line">        <span class="comment">// http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3.5</span></span><br><span class="line">        entry.responseHeaders.putAll(responseHeaders);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> NetworkResponse(HttpStatus.SC_NOT_MODIFIED, entry.data,</span><br><span class="line">                entry.responseHeaders, <span class="keyword">true</span>,</span><br><span class="line">                SystemClock.elapsedRealtime() - requestStart);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Some responses such as 204s do not have content.  We must check.</span></span><br><span class="line">    <span class="keyword">if</span> (httpResponse.getEntity() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      responseContents = entityToBytes(httpResponse.getEntity());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Add 0 byte response as a way of honestly representing a</span></span><br><span class="line">      <span class="comment">// no-content request.</span></span><br><span class="line">      responseContents = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// if the request is slow, log it.</span></span><br><span class="line">    <span class="keyword">long</span> requestLifetime = SystemClock.elapsedRealtime() - requestStart;</span><br><span class="line">    logSlowRequests(requestLifetime, request, responseContents, statusLine);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (statusCode &lt; <span class="number">200</span> || statusCode &gt; <span class="number">299</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> NetworkResponse(statusCode, responseContents, responseHeaders, <span class="keyword">false</span>,</span><br><span class="line">            SystemClock.elapsedRealtime() - requestStart);</span><br><span class="line">&#125; <span class="keyword">catch</span> (SocketTimeoutException e) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//省略各种Exception</span></span><br></pre></td></tr></table></figure></p><p>官方文档的注释很清楚，各种异常的处理也很规范，如果请求出错了，上层可以很简单的通过异常的类型来提示用户接下来的操作（连接超时点击重试、无网络点击去设置、未授权点击去登录、服务器异常等）。</p><p>##本地缓存的处理<br>最后看下Volley的文件缓存类DiskBasedCache<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DiskBasedCache</span><span class="params">(File rootDirectory, <span class="keyword">int</span> maxCacheSizeInBytes)</span> </span>&#123;</span><br><span class="line">    mRootDirectory = rootDirectory;</span><br><span class="line">    mMaxCacheSizeInBytes = maxCacheSizeInBytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过构造方法可以设置缓存文件夹的地址和大小（默认是5M，超过这个阀值再添加就会remove）</p><p>通过设置LinkedHashMap按照访问顺序排序来实现LRU算法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, CacheHeader&gt; mEntries =</span><br><span class="line">            <span class="keyword">new</span> LinkedHashMap&lt;String, CacheHeader&gt;(<span class="number">16</span>, .<span class="number">75f</span>, <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure></p><p>CacheHeader由从缓存文件中读取响应的Cache-Control头信息生成。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Puts the entry with the specified key into the cache.</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, Entry entry)</span> </span>&#123;</span><br><span class="line">    pruneIfNeeded(entry.data.length);</span><br><span class="line">    File file = getFileForKey(key);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        BufferedOutputStream fos = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(file));</span><br><span class="line">        CacheHeader e = <span class="keyword">new</span> CacheHeader(key, entry);</span><br><span class="line">        <span class="keyword">boolean</span> success = e.writeHeader(fos);</span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">            fos.close();</span><br><span class="line">            VolleyLog.d(<span class="string">"Failed to write header for %s"</span>, file.getAbsolutePath());</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException();</span><br><span class="line">        &#125;</span><br><span class="line">        fos.write(entry.data);</span><br><span class="line">        fos.close();</span><br><span class="line">        putEntry(key, e);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> deleted = file.delete();</span><br><span class="line">    <span class="keyword">if</span> (!deleted) &#123;</span><br><span class="line">        VolleyLog.d(<span class="string">"Could not clean up file %s"</span>, file.getAbsolutePath());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>put的时候先把响应的header部分写入文件，然后再写入body体。get在组装Entry对象的data数据时会从文件中把头信息过滤掉。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pruneIfNeeded</span><span class="params">(<span class="keyword">int</span> neededSpace)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((mTotalSize + neededSpace) &lt; mMaxCacheSizeInBytes) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Iterator&lt;Map.Entry&lt;String, CacheHeader&gt;&gt; iterator = mEntries.entrySet().iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        Map.Entry&lt;String, CacheHeader&gt; entry = iterator.next();</span><br><span class="line">        CacheHeader e = entry.getValue();</span><br><span class="line">        <span class="keyword">boolean</span> deleted = getFileForKey(e.key).delete();</span><br><span class="line">        <span class="keyword">if</span> (deleted) &#123;</span><br><span class="line">            mTotalSize -= e.size;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           VolleyLog.d(<span class="string">"Could not delete cache entry for key=%s, filename=%s"</span>,</span><br><span class="line">                   e.key, getFilenameForKey(e.key));</span><br><span class="line">        &#125;</span><br><span class="line">        iterator.remove();</span><br><span class="line">        prunedFiles++;</span><br><span class="line">        <span class="keyword">if</span> ((mTotalSize + neededSpace) &lt; mMaxCacheSizeInBytes * HYSTERESIS_FACTOR) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缓存文件大小达到设定的阀值后，找出排在LinkedHashMap最前面的（也就是时间最久未使用过的）文件，删除本地文件已经在LinkedHashMap中的数据，直到剩余的空间能够存下新的要add的缓存文件为止。<br>注意，这里在删除LinkedHashMap中元素的时候，要使用Iterator迭代器的方式，否则会报ConcurrentModificationException.</p><p>Volley初始化的时候通过initialize()方法会把本地所有的缓存文件缓存到内存中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">File[] files = mRootDirectory.listFiles();</span><br><span class="line"><span class="keyword">if</span> (files == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">    BufferedInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">    fis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(file));</span><br><span class="line">    CacheHeader entry = CacheHeader.readHeader(fis);</span><br><span class="line">    entry.size = file.length();</span><br><span class="line">    putEntry(entry.key, entry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里其实有一点问题，初始化的时候只是单纯的遍历所有缓存文件，并没有对缓存文件的有效期做校验。而通过上面CacheDispatcher的run()方法可知，如果缓存文件过期的话，请求就会走网络，而不使用缓存文件，此时缓存文件相当于是脏数据，没任何用。所以这里可以优化一下，在初始化的时候把过期的缓存删除掉，不仅能够减小缓存文件的磁盘空间占用，还能有效提高缓存的命中率（简单的依赖文件名进行遍历、添加，会导致有些过期的缓存文件在LinkedHashMap中放在没过期文件的后面，在缓存达到上限需要删除数据的时候就会把没过期的文件删除却保留了过期的缓存文件）。</p><p>##总结</p><ul><li><p>CacheDispatcher的run()方法是请求的入口，所有的请求都会先被添加到这里。请求存在缓存且可用则直接返回缓存数据，否则交给network线程处理。network线程数量可优化成动态调整。</p></li><li><p>获取服务器响应后，严格按照HTTP协议的规范解析Cache相关的头部信息，并保存到本地文件。同一个请求再次发出时，在header里带上本地缓存的Cache相关的头部信息。如果服务器并没有按照HTTP规范实现相关的缓存协议，Volley的缓存功能就失效了，每次请求都是一个新请求，所以需要服务端配合。</p></li><li><p>文件缓存通过LinkedHashMap实现LRU算法，管理对本地的缓存文件的操作。初始化缓存数据到LinkedHashMap中时可优化。</p></li></ul></div><footer class="article-footer"><a data-url="http://qianzui.github.io/blog/2014-07-23-volley-deal-with-http-cache/" data-id="ciolehcrm000rrnn7pzar3lnu" class="article-share-link">分享到</a> <a href="http://qianzui.github.io/blog/2014-07-23-volley-deal-with-http-cache/#ds-thread" class="article-comment-link">评论</a><ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Cache/">Cache</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Http/">Http</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Volley/">Volley</a></li></ul></footer></div><nav id="article-nav"><a href="/blog/2015-10-03-generate-key-from-url/" id="article-nav-newer" class="article-nav-link-wrap"><div class="article-nav-title"><i class="fa fa-chevron-left"></i> 根据URL生成缓存key算法</div></a> <a href="/blog/2014-05-25-tinypng-script-to-compress-images/" id="article-nav-older" class="article-nav-link-wrap"><div class="article-nav-title">使用TinyPNG批量压缩图片脚本 <i class="fa fa-chevron-right"></i></div></a></nav></article><section id="comments"><div id="ds-thread" class="ds-thread" data-thread-key="http://qianzui.github.io/blog/2014-07-23-volley-deal-with-http-cache/" data-title="Volley对HTTP缓存的处理" data-url="http://qianzui.github.io/blog/2014-07-23-volley-deal-with-http-cache/"><noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by DuoShuo.</a></noscript></div></section></section><aside id="sidebar"><div class="widget-wrap"><h3 class="widget-title">最新文章</h3><div class="widget"><ul id="recent-post" class="no-thumbnail"><li><div class="item-inner"><p class="item-category"><a class="article-category-link" href="/categories/Android/">Android</a></p><p class="item-title"><a href="/blog/2016-03-28-android-calculator-source-code-analysis/" class="title">Android原生计算器源码分析</a></p><p class="item-date"><time datetime="2016-03-28T15:51:27.000Z" itemprop="datePublished">2016-03-28</time></p></div></li><li><div class="item-inner"><p class="item-category"><a class="article-category-link" href="/categories/Android/">Android</a></p><p class="item-title"><a href="/blog/2015-10-03-generate-key-from-url/" class="title">根据URL生成缓存key算法</a></p><p class="item-date"><time datetime="2015-10-03T15:13:04.000Z" itemprop="datePublished">2015-10-03</time></p></div></li><li><div class="item-inner"><p class="item-category"><a class="article-category-link" href="/categories/Http/">Http</a></p><p class="item-title"><a href="/blog/2014-07-23-volley-deal-with-http-cache/" class="title">Volley对HTTP缓存的处理</a></p><p class="item-date"><time datetime="2014-07-23T11:11:31.000Z" itemprop="datePublished">2014-07-23</time></p></div></li><li><div class="item-inner"><p class="item-category"><a class="article-category-link" href="/categories/Android/">Android</a></p><p class="item-title"><a href="/blog/2014-05-25-tinypng-script-to-compress-images/" class="title">使用TinyPNG批量压缩图片脚本</a></p><p class="item-date"><time datetime="2014-05-25T11:58:37.000Z" itemprop="datePublished">2014-05-25</time></p></div></li><li><div class="item-inner"><p class="item-category"><a class="article-category-link" href="/categories/Android/">Android</a></p><p class="item-title"><a href="/blog/2014-04-21-why-volley-request-twice/" class="title">Volley默认请求多次原因解析</a></p><p class="item-date"><time datetime="2014-04-21T12:17:27.000Z" itemprop="datePublished">2014-04-21</time></p></div></li></ul></div></div><div class="widget-wrap"><h3 class="widget-title">分类</h3><div class="widget"><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Http/">Http</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/">设计模式</a><span class="category-list-count">1</span></li></ul></div></div><div class="widget-wrap"><h3 class="widget-title">标签</h3><div class="widget"><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cache/">Cache</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gson/">Gson</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Http/">Http</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OkHttp/">OkHttp</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/POST/">POST</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Picasso/">Picasso</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TinyPNG/">TinyPNG</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Volley/">Volley</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/file-upload/">file upload</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/二分查找/">二分查找</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/单例模式/">单例模式</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/布局优化/">布局优化</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/快速排序/">快速排序</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/源码解析/">源码解析</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/计算器/">计算器</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/面向对象/">面向对象</a><span class="tag-list-count">1</span></li></ul></div></div><div class="widget-wrap"><h3 class="widget-title">归档</h3><div class="widget"><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">三月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">十月 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/07/">七月 2014</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/05/">五月 2014</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/04/">四月 2014</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/02/">二月 2014</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/01/">一月 2014</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/12/">十二月 2013</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/07/">七月 2013</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/04/">四月 2013</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/03/">三月 2013</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/12/">十二月 2012</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/07/">七月 2012</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/05/">五月 2012</a><span class="archive-list-count">1</span></li></ul></div></div><div id="toTop" class="fa fa-chevron-up"></div></aside></div><footer id="footer"><div class="outer"><div id="footer-info" class="inner">&copy; 2016 千醉<br>Powered by <a href="http://hexo.io/" target="_blank" rel="external nofollow">Hexo</a>. Theme by <a href="https://github.com/hellochensq/hexo-theme-icarus" rel="external nofollow">Icarus</a>. Analyse with<script src="http://s23.cnzz.com/z_stat.php?id=1258283573&web_id=1258283573" language="JavaScript"></script></div></div></footer><script type="text/javascript">var duoshuoQuery={short_name:"qianzui"};!function(){var t=document.createElement("script");t.type="text/javascript",t.async=!0,t.src=("https:"==document.location.protocol?"https:":"http:")+"//static.duoshuo.com/embed.js",t.charset="UTF-8",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(t)}();</script><script src="//cdn.bootcss.com/jquery/2.2.0/jquery.min.js"></script><link rel="stylesheet" id="style-css" href="http://cdn.staticfile.org/fancybox/2.1.5/jquery.fancybox.css" type="text/css" media="screen"><script type="text/javascript" src="http://cdn.staticfile.org/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script src="/js/script.js"></script></div></body></html>