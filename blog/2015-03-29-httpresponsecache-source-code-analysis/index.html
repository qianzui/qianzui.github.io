<!DOCTYPE html><html><head><meta name="google-site-verification" content="l5IS67XsnEoE1xwi9zQCgXv7Axe5Uds5_IOXOmlZt6U"><meta name="baidu-site-verification" content="6Z8140QnmW"><meta charset="utf-8"><title>HttpResponseCache原理分析 | qianzui&#39;s blog</title><meta name="keywords" content="HttpResponseCache,原理,源码解析,Android,HttpURLConnection,Cache,Source Code"><meta http-equiv="content-language" content="zh-CN"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content="HttpResponseCache原理分析"><meta property="og:type" content="article"><meta property="og:title" content="HttpResponseCache原理分析"><meta property="og:url" content="http://qianzui.github.io/blog/2015-03-29-httpresponsecache-source-code-analysis/index.html"><meta property="og:site_name" content="qianzui's blog"><meta property="og:description" content="HttpResponseCache原理分析"><meta property="og:updated_time" content="2016-05-25T06:02:28.908Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="HttpResponseCache原理分析"><meta name="twitter:description" content="HttpResponseCache原理分析"><link rel="alternative" href="/atom.xml" title="qianzui&#39;s blog" type="application/atom+xml"><link rel="icon" href="/css/images/favicon.png"><link href="//fonts.useso.com/css?family=Open+Sans:400italic,400,600" rel="stylesheet" type="text/css"><link href="//fonts.useso.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css"><link rel="stylesheet" href="/css/style.css"><link href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"></head><body><div id="container"><header id="header"><div id="header-main" class="header-inner"><div class="outer"><a href="/" id="logo"><i class="logo"></i><span class="site-title">qianzui&#39;s blog</span></a><nav id="main-nav"><a class="main-nav-link" href="/">主页</a> <a class="main-nav-link" href="/archives">归档</a> <a class="main-nav-link" href="/about">关于</a></nav><nav id="sub-nav"><div class="profile" id="profile-nav"><a id="profile-anchor" href="javascript:;"><img class="avatar" src="http://cdn.fds.api.xiaomi.com/b2c-bbs/yoJtzqV9IWFb.png"><i class="fa fa-caret-down"></i></a></div></nav><div id="search-form-wrap"><form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"></button><input type="hidden" name="sitesearch" value="http://qianzui.github.io"></form></div></div></div><div id="main-nav-mobile" class="header-sub header-inner"><table class="menu outer"><tr><td><a class="main-nav-link" href="/">主页</a></td><td><a class="main-nav-link" href="/archives">归档</a></td><td><a class="main-nav-link" href="/about">关于</a></td><td><form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><input type="hidden" name="sitesearch" value="http://qianzui.github.io"></form></td></tr></table></div></header><div class="outer"><aside id="profile"><div class="inner profile-inner"><div class="base-info profile-block"><img id="avatar" src="http://cdn.fds.api.xiaomi.com/b2c-bbs/yoJtzqV9IWFb.png"><h2 id="name">千醉</h2><h3 id="title">Android Developer</h3><span id="location"><i class="fa fa-map-marker"></i>Beijing, China</span> <a id="follow" href="https://github.com/qianzui">关注我</a></div><div class="article-info profile-block"><div class="article-info-block">15 <span>文章</span></div><div class="article-info-block">18 <span>标签</span></div></div><div class="contact-info profile-block"><table class="contact-list"><tr><td><a href="http://github.com/qianzui" target="_blank" title="github"><div style="font-size: 26px"><i class="fa fa-github"></i></div></a></td><td><a href="http://weibo.com/qianzuiz" target="_blank" title="weibo"><div style="font-size: 26px"><i class="fa fa-weibo"></i></div></a></td><td><a href="https://plus.google.com/u/0/101333418418093394556/posts" target="_blank" title="google-plus"><div style="font-size: 26px"><i class="fa fa-google-plus"></i></div></a></td><td><a href="https://twitter.com/cuanzui" target="_blank" title="twitter"><div style="font-size: 26px"><i class="fa fa-twitter"></i></div></a></td></tr></table></div></div></aside><section id="main"><article id="post-httpresponsecache-source-code-analysis" class="article article-type-post" itemscope itemprop="blogPost"><div class="article-inner"><header class="article-header"><h1 class="article-title" itemprop="name">HttpResponseCache原理分析</h1><div class="article-meta"><div class="article-date"><i class="fa fa-calendar"></i> <a href="/blog/2015-03-29-httpresponsecache-source-code-analysis/"><time datetime="2015-03-29T11:11:59.000Z" itemprop="datePublished">2015-03-29</time></a></div><div class="article-category"><i class="fa fa-folder"></i> <a class="article-category-link" href="/categories/Android/">Android</a></div></div></header><div class="article-entry" itemprop="articleBody"><p>从Android4.0(API 14)开始，SDK源码中新增了一个类:android.net.http.HttpResponseCache.使用这个类可以很方便的对HTTP和HTTPS请求实现cache，所有的缓存逻辑再也不用自己写了，只要你使用HttpURLConnection或者HttpsURLConnection作为默认的网络请求库(也是Google官方建议使用的)，底层默认帮你实现的缓存的管理，不支持HttpClient。</p><p>根据developer文档介绍，开启HttpResponseCache很简单，只需要几行代码。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   File httpCacheDir = <span class="keyword">new</span> File(context.getCacheDir(), <span class="string">"http"</span>);</span><br><span class="line">   <span class="keyword">long</span> httpCacheSize = <span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>; <span class="comment">// 10 MiB</span></span><br><span class="line">   HttpResponseCache.install(httpCacheDir, httpCacheSize);</span><br><span class="line"><span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">   Log.i(TAG, <span class="string">"HTTP response cache installation failed:"</span> + e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上代码会在data/data/packagename/cache/下创建http文件夹，所有的http缓存文件默认都会存放到这个文件夹下，缓存文件夹最大为10M。<br>如果想兼容4.0以前的版本的话，可以用反射的方式调用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    File httpCacheDir = <span class="keyword">new</span> File(context.getCacheDir(), <span class="string">"http"</span>);</span><br><span class="line">    <span class="keyword">long</span> httpCacheSize = <span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>; <span class="comment">// 10 MiB</span></span><br><span class="line">    Class.forName(<span class="string">"android.net.http.HttpResponseCache"</span>)</span><br><span class="line">            .getMethod(<span class="string">"install"</span>, File.class, <span class="keyword">long</span>.class)</span><br><span class="line">            .invoke(<span class="keyword">null</span>, httpCacheDir, httpCacheSize);</span><br><span class="line">    <span class="keyword">catch</span> (Exception httpResponseCacheNotAvailable) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>开启完之后，如果服务端接口实现了http缓存协议，客户端发送http请求就会在http文件夹下产生缓存数据，下次再次请求的话，缓存如果还在有效期内，就会从缓存文件中读取。对缓存使用的控制可以通过设置不同的Cache-Control头部。</p><ul><li><p>如果不想使用本地缓存，直接请求服务器最新数据，比如下拉刷新，可以这么设置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connection.addRequestProperty(<span class="string">"Cache-Control"</span>, <span class="string">"no-cache"</span>);</span><br></pre></td></tr></table></figure></li><li><p>如果只想使用本地缓存，不去向服务器请求数据，可以这么设置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connection.addRequestProperty(<span class="string">"Cache-Control"</span>, <span class="string">"only-if-cached"</span>);</span><br></pre></td></tr></table></figure></li><li><p>如果既想使用本地缓存，又怕服务器数据有更新，需要服务器验证，可以这么设置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connection.addRequestProperty(<span class="string">"Cache-Control"</span>, <span class="string">"max-age=0"</span>);</span><br></pre></td></tr></table></figure></li><li><p>如果想设置缓存过期后的有效时间，可以这么设置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> maxStale = <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">28</span>; <span class="comment">// tolerate 4-weeks stale</span></span><br><span class="line">connection.addRequestProperty(<span class="string">"Cache-Control"</span>, <span class="string">"max-stale="</span> + maxStale);</span><br></pre></td></tr></table></figure></li></ul><p>以前看Picasso的源码，发现如果使用HttpUrlConnection就会开启HttpResponseCache，Disk Cache交给HttpResponseCache处理。如果使用OkHttp作为网络请求库，就使用OkHttp自带的Disk Cache。今天感兴趣HttpResponseCache这块底层的实现逻辑，到源码里看一下。<br><a id="more"></a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HttpResponseCache <span class="title">install</span><span class="params">(File directory, <span class="keyword">long</span> maxSize)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    HttpResponseCache installed = getInstalled();</span><br><span class="line">    <span class="keyword">if</span> (installed != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// don't close and reopen if an equivalent cache is already installed</span></span><br><span class="line">        DiskLruCache installedCache = installed.delegate.getCache();</span><br><span class="line">        <span class="keyword">if</span> (installedCache.getDirectory().equals(directory)</span><br><span class="line">                &amp;&amp; installedCache.maxSize() == maxSize</span><br><span class="line">                &amp;&amp; !installedCache.isClosed()) &#123;</span><br><span class="line">            <span class="keyword">return</span> installed;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            IoUtils.closeQuietly(installed);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HttpResponseCache result = <span class="keyword">new</span> HttpResponseCache(directory, maxSize);</span><br><span class="line">    ResponseCache.setDefault(result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HttpResponseCache <span class="title">getInstalled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ResponseCache installed = ResponseCache.getDefault();</span><br><span class="line">    <span class="keyword">return</span> installed <span class="keyword">instanceof</span> HttpResponseCache ? (HttpResponseCache) installed : <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>初次设置，会根据传入的directory和maxSize生成一个HttpResponseCache，并设置成默认的java.net.ResponseCache，到这里就完成了。<br>看一下调用HttpURLConnection发送请求的时候是如何处理缓存的以及响应结果是如何处理的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">URL url = <span class="keyword">new</span> URL(<span class="string">"http://localhost:8080/xxx.json"</span>)</span><br><span class="line">HttpURLConnection connection = (HttpURLConnection) url.openConnection();</span><br><span class="line">connection.setRequestMethod(<span class="string">"GET"</span>);</span><br><span class="line">connection.setUseCaches(<span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">if</span> (connection.getResponseCode() == <span class="number">200</span>) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这是使用HttpURLConnection发送请求最简单的用法，其实HttpURLConnection是一个继承于java.net.URLConnection的抽象类，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpURLConnection</span> <span class="keyword">extends</span> <span class="title">URLConnection</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>所有的方法都没有具体的实现，关键还是看一下调用URL.openConnection()生成的具体实例是谁。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> URLConnection <span class="title">openConnection</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> streamHandler.openConnection(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看一下这个streamHandler是什么，找到初始化的地方。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setupStreamHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line">    <span class="comment">// Fall back to a built-in stream handler if the user didn't supply one</span></span><br><span class="line">    <span class="keyword">if</span> (protocol.equals(<span class="string">"file"</span>)) &#123;</span><br><span class="line">        streamHandler = <span class="keyword">new</span> FileHandler();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (protocol.equals(<span class="string">"ftp"</span>)) &#123;</span><br><span class="line">        streamHandler = <span class="keyword">new</span> FtpHandler();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (protocol.equals(<span class="string">"http"</span>)) &#123;</span><br><span class="line">        streamHandler = <span class="keyword">new</span> HttpHandler();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (protocol.equals(<span class="string">"https"</span>)) &#123;</span><br><span class="line">        streamHandler = <span class="keyword">new</span> HttpsHandler();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (protocol.equals(<span class="string">"jar"</span>)) &#123;</span><br><span class="line">        streamHandler = <span class="keyword">new</span> JarHandler();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (streamHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">        streamHandlers.put(protocol, streamHandler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>根据不同的协议类型，对应不同的Handler，这里就是HttpsHandler。所以，url.openConnection()最终调用的是HttpsHandler的openConnection()方法，到libcore下去看一下。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> URLConnection <span class="title">openConnection</span><span class="params">(URL u)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HttpURLConnectionImpl(u, getDefaultPort());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>openConnection()方法最终返回了一个HttpURLConnectionImpl对象。所以抽象类HttpURLConnection的实现到这里就找到了，后面看看请求的过程，调用getResponseCode()的过程中究竟对缓存是如果操作的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getResponseCode</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getResponse().getResponseCode();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> HttpEngine <span class="title">getResponse</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    initHttpEngine();</span><br><span class="line">    <span class="keyword">if</span> (httpEngine.hasResponse()) &#123;</span><br><span class="line">        <span class="keyword">return</span> httpEngine;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            httpEngine.sendRequest();</span><br><span class="line">            httpEngine.readResponse();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        Retry retry = processResponseHeaders();</span><br><span class="line">        <span class="keyword">if</span> (retry == Retry.NONE) &#123;</span><br><span class="line">            httpEngine.automaticallyReleaseConnectionToPool();</span><br><span class="line">            <span class="keyword">return</span> httpEngine;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span><br><span class="line">         * The first request was insufficient. Prepare for another...</span><br><span class="line">         */</span></span><br><span class="line">        String retryMethod = method;</span><br><span class="line">        OutputStream requestBody = httpEngine.getRequestBody();</span><br><span class="line">        <span class="comment">/*</span><br><span class="line">         * Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM</span><br><span class="line">         * redirect should keep the same method, Chrome, Firefox and the</span><br><span class="line">         * RI all issue GETs when following any redirect.</span><br><span class="line">         */</span></span><br><span class="line">        <span class="keyword">int</span> responseCode = getResponseCode();</span><br><span class="line">        <span class="keyword">if</span> (responseCode == HTTP_MULT_CHOICE || responseCode == HTTP_MOVED_PERM</span><br><span class="line">                || responseCode == HTTP_MOVED_TEMP || responseCode == HTTP_SEE_OTHER) &#123;</span><br><span class="line">            retryMethod = HttpEngine.GET;</span><br><span class="line">            requestBody = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (requestBody != <span class="keyword">null</span> &amp;&amp; !(requestBody <span class="keyword">instanceof</span> RetryableOutputStream)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> HttpRetryException(<span class="string">"Cannot retry streamed HTTP body"</span>,</span><br><span class="line">                    httpEngine.getResponseCode());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (retry == Retry.DIFFERENT_CONNECTION) &#123;</span><br><span class="line">            httpEngine.automaticallyReleaseConnectionToPool();</span><br><span class="line">        &#125;</span><br><span class="line">        httpEngine.release(<span class="keyword">true</span>);</span><br><span class="line">        httpEngine = newHttpEngine(retryMethod, rawRequestHeaders,</span><br><span class="line">                httpEngine.getConnection(), (RetryableOutputStream) requestBody);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>initHttpEngine()方法会生成全局的httpEngine对象，13行、14行看方法名分别是发送发送请求、读取响应，感觉逻辑应该在这里。先看一下sendRequest()<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">sendRequest</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (responseSource != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    prepareRawRequestHeaders();</span><br><span class="line">    initResponseSource();</span><br><span class="line">    <span class="keyword">if</span> (responseCache <span class="keyword">instanceof</span> HttpResponseCache) &#123;</span><br><span class="line">        ((HttpResponseCache) responseCache).trackResponse(responseSource);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     * The raw response source may require the network, but the request</span><br><span class="line">     * headers may forbid network use. In that case, dispose of the network</span><br><span class="line">     * response and use a BAD_GATEWAY response instead.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">if</span> (requestHeaders.isOnlyIfCached() &amp;&amp; responseSource.requiresConnection()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (responseSource == ResponseSource.CONDITIONAL_CACHE) &#123;</span><br><span class="line">            IoUtils.closeQuietly(cachedResponseBody);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.responseSource = ResponseSource.CACHE;</span><br><span class="line">        <span class="keyword">this</span>.cacheResponse = BAD_GATEWAY_RESPONSE;</span><br><span class="line">        RawHeaders rawResponseHeaders = RawHeaders.fromMultimap(cacheResponse.getHeaders());</span><br><span class="line">        setResponse(<span class="keyword">new</span> ResponseHeaders(uri, rawResponseHeaders), cacheResponse.getBody());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (responseSource.requiresConnection()) &#123;</span><br><span class="line">        sendSocketRequest();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">        HttpConnectionPool.INSTANCE.recycle(connection);</span><br><span class="line">        connection = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>先看一下prepareRawRequestHeaders()<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">prepareRawRequestHeaders</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    requestHeaders.getHeaders().setStatusLine(getRequestLine());</span><br><span class="line">    <span class="keyword">if</span> (requestHeaders.getUserAgent() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        requestHeaders.setUserAgent(getDefaultUserAgent());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (requestHeaders.getHost() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        requestHeaders.setHost(getOriginAddress(policy.getURL()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (httpMinorVersion &gt; <span class="number">0</span> &amp;&amp; requestHeaders.getConnection() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        requestHeaders.setConnection(<span class="string">"Keep-Alive"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (requestHeaders.getAcceptEncoding() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        transparentGzip = <span class="keyword">true</span>;</span><br><span class="line">        requestHeaders.setAcceptEncoding(<span class="string">"gzip"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hasRequestBody() &amp;&amp; requestHeaders.getContentType() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        requestHeaders.setContentType(<span class="string">"application/x-www-form-urlencoded"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> ifModifiedSince = policy.getIfModifiedSince();</span><br><span class="line">    <span class="keyword">if</span> (ifModifiedSince != <span class="number">0</span>) &#123;</span><br><span class="line">        requestHeaders.setIfModifiedSince(<span class="keyword">new</span> Date(ifModifiedSince));</span><br><span class="line">    &#125;</span><br><span class="line">    CookieHandler cookieHandler = CookieHandler.getDefault();</span><br><span class="line">    <span class="keyword">if</span> (cookieHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">        requestHeaders.addCookies(</span><br><span class="line">                cookieHandler.get(uri, requestHeaders.getHeaders().toMultimap()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，从4.0开始，每一个请求底层都会默认开启gzip压缩和Keep-Alive连接复用。<br>再看一下initResponseSource()方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initResponseSource</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    responseSource = ResponseSource.NETWORK;</span><br><span class="line">    <span class="keyword">if</span> (!policy.getUseCaches() || responseCache == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    CacheResponse candidate = responseCache.get(uri, method,</span><br><span class="line">            requestHeaders.getHeaders().toMultimap());</span><br><span class="line">    <span class="keyword">if</span> (candidate == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Map&lt;String, List&lt;String&gt;&gt; responseHeadersMap = candidate.getHeaders();</span><br><span class="line">    cachedResponseBody = candidate.getBody();</span><br><span class="line">    <span class="keyword">if</span> (!acceptCacheResponseType(candidate)</span><br><span class="line">            || responseHeadersMap == <span class="keyword">null</span></span><br><span class="line">            || cachedResponseBody == <span class="keyword">null</span>) &#123;</span><br><span class="line">        IoUtils.closeQuietly(cachedResponseBody);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    RawHeaders rawResponseHeaders = RawHeaders.fromMultimap(responseHeadersMap);</span><br><span class="line">    cachedResponseHeaders = <span class="keyword">new</span> ResponseHeaders(uri, rawResponseHeaders);</span><br><span class="line">    <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">this</span>.responseSource = cachedResponseHeaders.chooseResponseSource(now, requestHeaders);</span><br><span class="line">    <span class="keyword">if</span> (responseSource == ResponseSource.CACHE) &#123;</span><br><span class="line">        <span class="keyword">this</span>.cacheResponse = candidate;</span><br><span class="line">        setResponse(cachedResponseHeaders, cachedResponseBody);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (responseSource == ResponseSource.CONDITIONAL_CACHE) &#123;</span><br><span class="line">        <span class="keyword">this</span>.cacheResponse = candidate;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (responseSource == ResponseSource.NETWORK) &#123;</span><br><span class="line">        IoUtils.closeQuietly(cachedResponseBody);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第6行的responseCache是全局变量,<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ResponseCache responseCache = ResponseCache.getDefault();</span><br></pre></td></tr></table></figure></p><p>还记得我们开始缓存的install的方法吗？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HttpResponseCache result = <span class="keyword">new</span> HttpResponseCache(directory, maxSize);</span><br><span class="line">ResponseCache.setDefault(result);</span><br></pre></td></tr></table></figure></p><p>先set，再get。所以这里的responseCache就是HttpResponseCache。initResponseSource()这里就是缓存的请求发送前缓存的处理逻辑。<br>第6行从本地缓存文件中读取缓存数据，没有缓存的话直接返回，否则对缓存数据进行一些列的处理和转化，第22行调用chooseResponseSource()判断缓存数据是否过期、可用与否。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ResponseSource <span class="title">chooseResponseSource</span><span class="params">(<span class="keyword">long</span> nowMillis, RequestHeaders request)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     * If this response shouldn't have been stored, it should never be used</span><br><span class="line">     * as a response source. This check should be redundant as long as the</span><br><span class="line">     * persistence store is well-behaved and the rules are constant.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!isCacheable(request)) &#123;</span><br><span class="line">        <span class="keyword">return</span> ResponseSource.NETWORK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (request.isNoCache() || request.hasConditions()) &#123;</span><br><span class="line">        <span class="keyword">return</span> ResponseSource.NETWORK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> ageMillis = computeAge(nowMillis);</span><br><span class="line">    <span class="keyword">long</span> freshMillis = computeFreshnessLifetime();</span><br><span class="line">    <span class="keyword">if</span> (request.getMaxAgeSeconds() != -<span class="number">1</span>) &#123;</span><br><span class="line">        freshMillis = Math.min(freshMillis,</span><br><span class="line">                TimeUnit.SECONDS.toMillis(request.getMaxAgeSeconds()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> minFreshMillis = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (request.getMinFreshSeconds() != -<span class="number">1</span>) &#123;</span><br><span class="line">        minFreshMillis = TimeUnit.SECONDS.toMillis(request.getMinFreshSeconds());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> maxStaleMillis = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!mustRevalidate &amp;&amp; request.getMaxStaleSeconds() != -<span class="number">1</span>) &#123;</span><br><span class="line">        maxStaleMillis = TimeUnit.SECONDS.toMillis(request.getMaxStaleSeconds());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!noCache &amp;&amp; ageMillis + minFreshMillis &lt; freshMillis + maxStaleMillis) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ageMillis + minFreshMillis &gt;= freshMillis) &#123;</span><br><span class="line">            headers.add(<span class="string">"Warning"</span>, <span class="string">"110 HttpURLConnection \"Response is stale\""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ageMillis &gt; TimeUnit.HOURS.toMillis(<span class="number">24</span>) &amp;&amp; isFreshnessLifetimeHeuristic()) &#123;</span><br><span class="line">            headers.add(<span class="string">"Warning"</span>, <span class="string">"113 HttpURLConnection \"Heuristic expiration\""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ResponseSource.CACHE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (lastModified != <span class="keyword">null</span>) &#123;</span><br><span class="line">        request.setIfModifiedSince(lastModified);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (servedDate != <span class="keyword">null</span>) &#123;</span><br><span class="line">        request.setIfModifiedSince(servedDate);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (etag != <span class="keyword">null</span>) &#123;</span><br><span class="line">        request.setIfNoneMatch(etag);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> request.hasConditions()</span><br><span class="line">            ? ResponseSource.CONDITIONAL_CACHE</span><br><span class="line">            : ResponseSource.NETWORK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>逻辑不太复杂，如果设置了本次请求不需要缓存或者缓存不存在，直接返回ResponseSource.NETWORK；如果有缓存且没过期则返回ResponseSource.CACHE；如果缓存不再新鲜需要向服务器验证则返回ResponseSource.CONDITIONAL_CACHE，同时会更新Request的和缓存相关的头信息（37行——If-Modified-Since、39行——If-None-Match）。</p><p>initResponseSource()方法的23行会根据返回的ResponseSource进行逻辑处理，是直接返回缓存数据(setResponse())，还是带上缓存头部向服务器请求，还是不使用缓存向服务器请求新数据。</p><p>再回到sendRequest()方法中，第24行，根据上面对缓存的各种处理和判断，如果responseSource不等于ResponseSource.CACHE则发送网络请求，否则关闭Connect。</p><p>请求这块到这里就明白啦，再看一下响应的处理。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">readResponse</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hasResponse()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (responseSource == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"readResponse() without sendRequest()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!responseSource.requiresConnection()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sentRequestMillis == -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> contentLength = requestBodyOut <span class="keyword">instanceof</span> RetryableOutputStream</span><br><span class="line">                ? ((RetryableOutputStream) requestBodyOut).contentLength()</span><br><span class="line">                : -<span class="number">1</span>;</span><br><span class="line">        writeRequestHeaders(contentLength);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (requestBodyOut != <span class="keyword">null</span>) &#123;</span><br><span class="line">        requestBodyOut.close();</span><br><span class="line">        <span class="keyword">if</span> (requestBodyOut <span class="keyword">instanceof</span> RetryableOutputStream) &#123;</span><br><span class="line">            ((RetryableOutputStream) requestBodyOut).writeToSocket(requestOut);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    requestOut.flush();</span><br><span class="line">    requestOut = socketOut;</span><br><span class="line">    readResponseHeaders();</span><br><span class="line">    responseHeaders.setLocalTimestamps(sentRequestMillis, System.currentTimeMillis());</span><br><span class="line">    <span class="keyword">if</span> (responseSource == ResponseSource.CONDITIONAL_CACHE) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cachedResponseHeaders.validate(responseHeaders)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (responseCache <span class="keyword">instanceof</span> HttpResponseCache) &#123;</span><br><span class="line">                ((HttpResponseCache) responseCache).trackConditionalCacheHit();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Discard the network response body. Combine the headers.</span></span><br><span class="line">            release(<span class="keyword">true</span>);</span><br><span class="line">            setResponse(cachedResponseHeaders.combine(responseHeaders), cachedResponseBody);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            IoUtils.closeQuietly(cachedResponseBody);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hasResponseBody()) &#123;</span><br><span class="line">        maybeCache(); <span class="comment">// reentrant. this calls into user code which may call back into this!</span></span><br><span class="line">    &#125;</span><br><span class="line">    initContentStream(getTransferStream());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>28行，如果服务器返回304 NOT_MODIFIED，说明服务端数据没更新、缓存可用，直接返回。看下41行的maybeCache()方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">maybeCache</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// Are we caching at all?</span></span><br><span class="line">    <span class="keyword">if</span> (!policy.getUseCaches() || responseCache == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Should we cache this response for this request?</span></span><br><span class="line">    <span class="keyword">if</span> (!responseHeaders.isCacheable(requestHeaders)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Offer this request to the cache.</span></span><br><span class="line">    cacheRequest = responseCache.put(uri, getHttpConnectionToCache());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第3行，如果设置了connection.setUseCaches(true)并且开启了HttpResponseCache才会保存缓存。第7行判断返回结果是否成功、服务器是否允许缓存，都通过的话最后把缓存数据保存到文件中去。到此关于缓存响应部分的处理就结束啦。</p><p>通过上面分析可以看到，Android底层关于缓存的处理严格遵循了HTTP的规范，通过设置不同的和缓存相关的头部信息进行缓存的判断和使用。这块和OKHttp底层的处理逻辑很像，感觉Android应该是借鉴了OkHttp代码的实现。</p></div><footer class="article-footer"><a data-url="http://qianzui.github.io/blog/2015-03-29-httpresponsecache-source-code-analysis/" data-id="cipfa38x2000uogn7v9ig0bbe" class="article-share-link">分享到</a> <a href="http://qianzui.github.io/blog/2015-03-29-httpresponsecache-source-code-analysis/#ds-thread" class="article-comment-link">评论</a><ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HttpResponseCache/">HttpResponseCache</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/源码解析/">源码解析</a></li></ul></footer></div><nav id="article-nav"><a href="/blog/2015-10-03-generate-key-from-url/" id="article-nav-newer" class="article-nav-link-wrap"><div class="article-nav-title"><i class="fa fa-chevron-left"></i> 根据URL生成缓存key算法</div></a> <a href="/blog/2014-07-23-volley-deal-with-http-cache/" id="article-nav-older" class="article-nav-link-wrap"><div class="article-nav-title">Volley对HTTP缓存的处理 <i class="fa fa-chevron-right"></i></div></a></nav></article><section id="comments"><div id="ds-thread" class="ds-thread" data-thread-key="http://qianzui.github.io/blog/2015-03-29-httpresponsecache-source-code-analysis/" data-title="HttpResponseCache原理分析" data-url="http://qianzui.github.io/blog/2015-03-29-httpresponsecache-source-code-analysis/"><noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by DuoShuo.</a></noscript></div></section></section><aside id="sidebar"><div class="widget-wrap"><h3 class="widget-title">最新文章</h3><div class="widget"><ul id="recent-post" class="no-thumbnail"><li><div class="item-inner"><p class="item-category"><a class="article-category-link" href="/categories/Android/">Android</a></p><p class="item-title"><a href="/blog/2016-03-28-android-calculator-source-code-analysis/" class="title">Android原生计算器源码分析</a></p><p class="item-date"><time datetime="2016-03-28T15:51:27.000Z" itemprop="datePublished">2016-03-28</time></p></div></li><li><div class="item-inner"><p class="item-category"><a class="article-category-link" href="/categories/Android/">Android</a></p><p class="item-title"><a href="/blog/2015-10-03-generate-key-from-url/" class="title">根据URL生成缓存key算法</a></p><p class="item-date"><time datetime="2015-10-03T15:13:04.000Z" itemprop="datePublished">2015-10-03</time></p></div></li><li><div class="item-inner"><p class="item-category"><a class="article-category-link" href="/categories/Android/">Android</a></p><p class="item-title"><a href="/blog/2015-03-29-httpresponsecache-source-code-analysis/" class="title">HttpResponseCache原理分析</a></p><p class="item-date"><time datetime="2015-03-29T11:11:59.000Z" itemprop="datePublished">2015-03-29</time></p></div></li><li><div class="item-inner"><p class="item-category"><a class="article-category-link" href="/categories/Http/">Http</a></p><p class="item-title"><a href="/blog/2014-07-23-volley-deal-with-http-cache/" class="title">Volley对HTTP缓存的处理</a></p><p class="item-date"><time datetime="2014-07-23T11:11:31.000Z" itemprop="datePublished">2014-07-23</time></p></div></li><li><div class="item-inner"><p class="item-category"><a class="article-category-link" href="/categories/Android/">Android</a></p><p class="item-title"><a href="/blog/2014-05-25-tinypng-script-to-compress-images/" class="title">使用TinyPNG批量压缩图片脚本</a></p><p class="item-date"><time datetime="2014-05-25T11:58:37.000Z" itemprop="datePublished">2014-05-25</time></p></div></li></ul></div></div><div class="widget-wrap"><h3 class="widget-title">分类</h3><div class="widget"><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Http/">Http</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/">设计模式</a><span class="category-list-count">1</span></li></ul></div></div><div class="widget-wrap"><h3 class="widget-title">标签</h3><div class="widget"><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cache/">Cache</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gson/">Gson</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Http/">Http</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HttpResponseCache/">HttpResponseCache</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OkHttp/">OkHttp</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/POST/">POST</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Picasso/">Picasso</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TinyPNG/">TinyPNG</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Volley/">Volley</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/file-upload/">file upload</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/二分查找/">二分查找</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/单例模式/">单例模式</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/布局优化/">布局优化</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/快速排序/">快速排序</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/源码解析/">源码解析</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/计算器/">计算器</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/面向对象/">面向对象</a><span class="tag-list-count">1</span></li></ul></div></div><div class="widget-wrap"><h3 class="widget-title">归档</h3><div class="widget"><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">三月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">十月 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/03/">三月 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/07/">七月 2014</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/05/">五月 2014</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/04/">四月 2014</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/02/">二月 2014</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/01/">一月 2014</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/12/">十二月 2013</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/07/">七月 2013</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/04/">四月 2013</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/03/">三月 2013</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/12/">十二月 2012</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/07/">七月 2012</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/05/">五月 2012</a><span class="archive-list-count">1</span></li></ul></div></div><div id="toTop" class="fa fa-chevron-up"></div></aside></div><footer id="footer"><div class="outer"><div id="footer-info" class="inner">&copy; 2016 千醉<br>Powered by <a href="http://hexo.io/" target="_blank" rel="external nofollow">Hexo</a>. Theme by <a href="https://github.com/hellochensq/hexo-theme-icarus" rel="external nofollow">Icarus</a>. Analyse with<script src="http://s23.cnzz.com/z_stat.php?id=1258283573&web_id=1258283573" language="JavaScript"></script></div></div></footer><script type="text/javascript">var duoshuoQuery={short_name:"qianzui"};!function(){var t=document.createElement("script");t.type="text/javascript",t.async=!0,t.src=("https:"==document.location.protocol?"https:":"http:")+"//static.duoshuo.com/embed.js",t.charset="UTF-8",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(t)}();</script><script src="//cdn.bootcss.com/jquery/2.2.0/jquery.min.js"></script><link rel="stylesheet" id="style-css" href="http://cdn.staticfile.org/fancybox/2.1.5/jquery.fancybox.css" type="text/css" media="screen"><script type="text/javascript" src="http://cdn.staticfile.org/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script src="/js/script.js"></script></div></body></html>